#include <iostream>
#include <fstream>
#include <sstream>
#include <string>
#include "board.h"
#include "textdisplay.h"
#include "command.h"
#include "levelzero.h"
#include "levelone.h"
#include "leveltwo.h"
#include "levelthree.h"
#include "levelfour.h"
#include "iblock.h"
#include "jblock.h"
#include "oblock.h"
#include "sblock.h"
#include "zblock.h"
#include "tblock.h"
#include "lblock.h"
#include "starblock.h"
using namespace std;

/*
Command Index (0 ~ 12):
0 "left",
1 "right",
2 "down",
3 "clockwise",
4 "counterclockwise",
5 "drop",
6 "levelup",
7 "leveldown",
8 "norandom",
9 "random",
10 "sequence",
11 "restart",
12 "hint"
*/

int main(int argc, char *argv[]){
  string commandInput;
  // commandStream for commandLine argument interpreting
  stringstream commandStream;
  // default scriptFile
  string scriptFile = "sequence.txt";
  // textOnlyMode indicator
  bool textOnlyMode = false;
  // keeps track of currentLevel as an integer
  int currentLevel = 0;
  int initLevel = 0;
  bool levelChanged = false;
  // keeps track of seed
  int seed = 0;
  // input arguments into commandStream
  for (int i = 1; i < argc; ++i){
    string argument = argv[i];
    commandStream << argument << " ";
  }
  // Commandline argument interpreter
  string singleCommand;
  while(commandStream >> singleCommand){
    if (singleCommand == "-text"){
      textOnlyMode = true;
    } else if (singleCommand == "-seed"){
      int newSeed;
      commandStream >> newSeed;
      seed = newSeed;
    } else if (singleCommand == "-scriptfile"){
      string newScriptFile;
      commandStream >> newScriptFile;
      scriptFile = newScriptFile;
    } else if (singleCommand == "-startlevel"){
      int n;
      commandStream >> n;
      if (n >= 0 && n <= 4){
        currentLevel = n;
        initLevel = n;
      }
    }
  }
  // game starts
  auto gameBoard = make_unique<Board>();
  gameBoard->init(textOnlyMode);
  gameBoard->levelChange(currentLevel);
  // currentLevelPtr is the real level object which will generate blocks
  shared_ptr<Level> currentLevelPtr = make_shared<LevelZero>();

  // currentBlock is for storing the currentBlock generated by level
  // I block is not what we are using, but the ctor needs a type so randomly
  // chosed I.
  shared_ptr<Block> currentBlock = make_shared<IBlock>(0);
  bool needNewBlock = false;

  // nextBlock is for storing the nextBlock generated by level
  shared_ptr<Block> nextBlock = make_shared<IBlock>(0);

  // prepared a ifstream when level 0 needs to read from scriptFile
  ifstream inputFromFile{scriptFile};

  // prepared a ifstream if level 3&4 needs to read from file
  ifstream norandomFile;
  bool norandomReadFromFile = false;
  string norandomInputFile;

  // prepared a boolean to check if game is restarted;
  bool restartGame = false;

  // keeps track os how many blocks is placed before clear at level four
  int blockPlacedBeforeClear = 0;
  bool rowCleared = false;

  // check if the game is just started
  bool startOfNewGame = false;

  // indicator for hint used
  bool usedHint = false;

  // indicator for hold used
  bool usedHold = false;

  // indicator for receiving input from user or file
  bool commandFromUser = true;
  bool commandFromFile = false;
  string commandFromFilePath = "";
  ifstream commandFromFileGetter;
  bool openCommandFile = false;

  if (seed != 0){
    switch(currentLevel){
      case 0: currentLevelPtr = make_shared<LevelZero>(); break;
      case 1: currentLevelPtr = make_shared<LevelOne>(seed); break;
      case 2: currentLevelPtr = make_shared<LevelTwo>(seed); break;
      case 3: currentLevelPtr = make_shared<LevelThree>(seed); break;
      case 4: currentLevelPtr = make_shared<LevelFour>(seed); break;
      default: break;
    }
  } else {
    switch(currentLevel){
      case 0: currentLevelPtr = make_shared<LevelZero>(); break;
      case 1: currentLevelPtr = make_shared<LevelOne>(); break;
      case 2: currentLevelPtr = make_shared<LevelTwo>(); break;
      case 3: currentLevelPtr = make_shared<LevelThree>(); break;
      case 4: currentLevelPtr = make_shared<LevelFour>(); break;
      default: break;
    }
  }

// preparing first two block before game start
// first prepare the first block
  if (currentLevel == 0){  // check to see if it's level 0
    char input;
    if (inputFromFile >> input){
      nextBlock = currentLevelPtr->doGenerate(input);
    } else {
      cout << "Error: Level zero file not found." << endl;
      return 1;
    }
  } else if (norandomReadFromFile) {
    char input;
    norandomFile >> input;
    nextBlock = currentLevelPtr->doGenerate(input);
  } else {
    nextBlock = currentLevelPtr->doGenerate();
  }

  currentBlock = nextBlock;
// now prepare the next block
  if (currentLevel == 0){  // check to see if it's level 0
    char input;
    inputFromFile >> input;
    nextBlock = currentLevelPtr->doGenerate(input);
  } else if (norandomReadFromFile) {
    char input;
    norandomFile >> input;
    nextBlock = currentLevelPtr->doGenerate(input);
  } else {
    nextBlock = currentLevelPtr->doGenerate();
  }
  gameBoard->sendNextBlock(nextBlock);
  gameBoard->sendCurrentBlock(currentBlock, false);

// prints gameBoard first time
  cout << *gameBoard;


// game started, receive commands
  while(true){

    if (restartGame){
      usedHold = false;
      gameBoard->init(textOnlyMode);
      norandomFile.close();
      inputFromFile.close();
      inputFromFile.open(scriptFile);
      norandomReadFromFile = false;
      blockPlacedBeforeClear = 0;
      rowCleared = 0;
      currentLevel = initLevel;
      needNewBlock = true;
      startOfNewGame = true;
      levelChanged = true;
    }

    // check for level changes after the last command
    if (levelChanged){
      if (seed != 0){
        switch(currentLevel){
          case 0: currentLevelPtr = make_shared<LevelZero>(); break;
          case 1: currentLevelPtr = make_shared<LevelOne>(seed); break;
          case 2: currentLevelPtr = make_shared<LevelTwo>(seed); break;
          case 3: currentLevelPtr = make_shared<LevelThree>(seed); break;
          case 4: currentLevelPtr = make_shared<LevelFour>(seed); break;
          default: break;
        }
      } else {
        switch(currentLevel){
          case 0: currentLevelPtr = make_shared<LevelZero>(); break;
          case 1: currentLevelPtr = make_shared<LevelOne>(); break;
          case 2: currentLevelPtr = make_shared<LevelTwo>(); break;
          case 3: currentLevelPtr = make_shared<LevelThree>(); break;
          case 4: currentLevelPtr = make_shared<LevelFour>(); break;
          default: break;
        }
      }
      gameBoard->levelChange(currentLevel);
      levelChanged = false;
      if (!restartGame){
        cout << *gameBoard;
      }
    }

    // check if the game is just started. If yes, prepare the first block
    if (startOfNewGame){
      char input;
      inputFromFile >> input;
      nextBlock = currentLevelPtr->doGenerate(input);
      startOfNewGame = false;
    }

    // check if new block is needed
    if (needNewBlock){
      needNewBlock = false;
      currentBlock = nextBlock;
      if (currentLevel == 0){  // check to see if it's level 0
        char input;
        inputFromFile >> input;
        nextBlock = currentLevelPtr->doGenerate(input);
      } else if (norandomReadFromFile) {
        char input;
        norandomFile >> input;
        nextBlock = currentLevelPtr->doGenerate(input);
      } else {
        nextBlock = currentLevelPtr->doGenerate();
      }
      gameBoard->sendCurrentBlock(currentBlock, false);
      gameBoard->sendNextBlock(nextBlock);
    }

    if (restartGame){
      restartGame = false;
      cout << *gameBoard;
    }


    // receive input from file input
    if (commandFromFile){
      commandFromUser = false;
      if (openCommandFile){
        commandFromFileGetter.open(commandFromFilePath);
        if (!commandFromFileGetter){
          cout << "Error: File did not open." << endl;
          commandFromUser = true;
          commandFromFile = false;
        }
        openCommandFile = false;
      }
      if (commandFromFileGetter >> commandInput){
      } else {
        cout << "Sequence file ended." << endl;
        commandFromFileGetter.close();
        commandFromUser = true;
        commandFromFile = false;
      }
    }
    // receive input from user input
    if (commandFromUser){
      cin >> commandInput;
      commandFromFile = false;
      commandFromFileGetter.close();
      if (cin.eof()){
        return 0;
      } else if (cin.fail()){
        return 1;
      }
    }

    // clear hint
    if (usedHint){
      usedHint = false;
      gameBoard->clearHint();
    }


    // interpreting commands
    string currentCommand;
    int executeTimes;
    int commandIndex;
    CommandInterpreter c{commandInput};
    if (!c.isValid()){  // command is invalid, ignore
      cout << "Invalid Command" << endl;
      continue;
    } else {
      commandIndex = c.getCommandIndex();
      executeTimes = c.getExecuteTimes();
      // use commandIndex as switch argument since string cannot be used
      // as switch argument
      // please refer to the top for the commands corresponding to commandIndex
      switch(commandIndex){
        //left
        case 0: {
          gameBoard->move('l', executeTimes);
          if (currentLevel >= 3){
            gameBoard->move('d', 1);
          }
          break;
        }
        //right
        case 1: {
          gameBoard->move('r', executeTimes);
          if (currentLevel >= 3){
            gameBoard->move('d', 1);
          }
          break;
        }
        //down
        case 2: {
          gameBoard->move('d', executeTimes);
          if (currentLevel >= 3){
            gameBoard->move('d', 1);
          }
          break;
        }
        //clockwise
        case 3: {
          int actualExecuteTimes = executeTimes % 4;
          gameBoard->rotate('r', actualExecuteTimes);
          if (currentLevel >= 3){
            gameBoard->move('d', 1);
          }
          break;
        }
        //counterclockwise
        case 4: {
          int actualExecuteTimes = executeTimes % 4;
          gameBoard->rotate('l', actualExecuteTimes);
          if (currentLevel >= 3){
            gameBoard->move('d', 1);
          }
          break;
        }
        //drop
        case 5: {
          for (int i = 0; i < executeTimes; ++i){
            bool dropped = gameBoard->drop(rowCleared);
            if (!dropped){
              cout << *gameBoard;
              cout << "Sorry, you lost. Please try again." << endl;
              gameBoard->sendLostToGraphic();
              commandFromFile = false;
              commandFromUser = true;
              string in;
              while (cin >> in){
                executeTimes = -1;
                CommandInterpreter c{in};
                if (!c.isValid()){  // command is invalid, ignore
                  continue;
                } else {
                  commandIndex = c.getCommandIndex();
                }
                if (commandIndex == 11){
                  restartGame = true;
                  break;
                }
              }
              if (cin.eof() || cin.fail()){
                return 0;
              }
            } else {
              usedHold = false;
              if (currentLevel >= 4){
                ++blockPlacedBeforeClear;
                if (rowCleared){
                  blockPlacedBeforeClear = 0;
                  rowCleared = false;
                } else if (!rowCleared && blockPlacedBeforeClear == 5){
                  gameBoard->dropStarBlock(rowCleared);
                  blockPlacedBeforeClear = 0;
                }
              }
              currentBlock = nextBlock;
              if (currentLevel == 0){  // check to see if it's level 0
                char input;
                if (inputFromFile >> input){
                  nextBlock = currentLevelPtr->doGenerate(input);
                } else {
                  inputFromFile.close();
                  inputFromFile.open(scriptFile);
                  inputFromFile >> input;
                  nextBlock = currentLevelPtr->doGenerate(input);
                }
              } else if (norandomReadFromFile) {
                char input;
                if (norandomFile >> input){
                  nextBlock = currentLevelPtr->doGenerate(input);
                } else {
                  norandomFile.close();
                  norandomFile.open(norandomInputFile);
                  norandomFile >> input;
                  nextBlock = currentLevelPtr->doGenerate(input);
                }
              } else {
                nextBlock = currentLevelPtr->doGenerate();
              }
              bool success = gameBoard->sendCurrentBlock(currentBlock, false);
              if (!success){
                cout << *gameBoard;
                cout << "Sorry, you lost. Please try again." << endl;
                gameBoard->sendLostToGraphic();
                commandFromFile = false;
                commandFromUser = true;
                string in;
                while (cin >> in){
                  executeTimes = -1;
                  CommandInterpreter c{in};
                  if (!c.isValid()){  // command is invalid, ignore
                    continue;
                  } else {
                    commandIndex = c.getCommandIndex();
                  }
                  if (commandIndex == 11){
                    restartGame = true;
                    break;
                  }
                }
                if (cin.eof() || cin.fail()){
                  return 0;
                }
              } else {
                gameBoard->sendNextBlock(nextBlock);
              }
            }
          }
          break;
        }
        //levelup
        case 6: {
          int previousLevel = currentLevel;
          for (int i = 0; i < executeTimes; ++i){
            ++currentLevel;
            levelChanged = true;
          }
          if (currentLevel > 4){
            currentLevel = 4;
          }
          if (currentLevel != previousLevel){
            levelChanged = true;
          }
          break;
        }
        //leveldown
        case 7: {
          int previousLevel = currentLevel;
          for (int i = 0; i < executeTimes; ++i){
            --currentLevel;
          }
          if (currentLevel < 0){
            currentLevel = 0;
          }
          if (currentLevel != previousLevel){
            levelChanged = true;
          }
          break;
        }
        //norandom
        case 8: {
          if (commandFromUser){
            cin >> norandomInputFile;
            if (cin.eof()){
              return 0;
            }
          } else if (commandFromFile){
            if (commandFromFileGetter >> norandomInputFile){}
            else {
              cout << "Sequence file ended, please type in norandom filename" << endl;
              commandFromFile = false;
              commandFromUser = true;
              cin >> norandomInputFile;
              if (cin.eof()){
                return 0;
              }
            }
          }
          if (currentLevel >= 3){
            norandomFile.open(norandomInputFile);
            norandomReadFromFile = true;
          }
          break;
        }
        //random
        case 9: {
          if (currentLevel >= 3){
            norandomFile.close();
            norandomReadFromFile = false;
          }
          break;
        }
        //sequence
        case 10: {
          cin >> commandFromFilePath;
          if (cin.eof()){
            return 0;
          }
          commandFromFile = true;
          openCommandFile = true;
          break;
        }
        //restart
        case 11: {
          restartGame = true;
          break;
        }
        //hint
        case 12: {
          // this is the place for hint
          gameBoard->hint();
          usedHint = true;
          break;
        }
        case 13: {
          currentBlock = currentLevelPtr->doGenerate('I');
          gameBoard->sendCurrentBlock(currentBlock, true);
          break;
        }
        case 14: {
          currentBlock = currentLevelPtr->doGenerate('J');
          gameBoard->sendCurrentBlock(currentBlock, true);
          break;
        }
        case 15: {
          currentBlock = currentLevelPtr->doGenerate('O');
          gameBoard->sendCurrentBlock(currentBlock, true);
          break;
        }
        case 16: {
          currentBlock = currentLevelPtr->doGenerate('S');
          gameBoard->sendCurrentBlock(currentBlock, true);
          break;
        }
        case 17: {
          currentBlock = currentLevelPtr->doGenerate('Z');
          gameBoard->sendCurrentBlock(currentBlock, true);
          break;
        }
        case 18: {
          currentBlock = currentLevelPtr->doGenerate('T');
          gameBoard->sendCurrentBlock(currentBlock, true);
          break;
        }
        case 19: {
          currentBlock = currentLevelPtr->doGenerate('L');
          gameBoard->sendCurrentBlock(currentBlock, true);
          break;
        }
        case 20: {
          if (!usedHold){
            usedHold = true;
            bool alreadyHold = gameBoard->hold(currentLevelPtr);
            if (!alreadyHold){
              currentBlock = nextBlock;
              if (currentLevel == 0){  // check to see if it's level 0
                char input;
                if (inputFromFile >> input){
                  nextBlock = currentLevelPtr->doGenerate(input);
                } else {
                  inputFromFile.close();
                  inputFromFile.open(scriptFile);
                  inputFromFile >> input;
                  nextBlock = currentLevelPtr->doGenerate(input);
                }
              } else if (norandomReadFromFile) {
                char input;
                if (norandomFile >> input){
                  nextBlock = currentLevelPtr->doGenerate(input);
                } else {
                  norandomFile.close();
                  norandomFile.open(norandomInputFile);
                  norandomFile >> input;
                  nextBlock = currentLevelPtr->doGenerate(input);
                }
              } else {
                nextBlock = currentLevelPtr->doGenerate();
              }
              gameBoard->sendCurrentBlock(currentBlock, false);
              gameBoard->sendNextBlock(nextBlock);
            }
          } else {
            cout << "Hold already used this turn." << endl;
          }
          break;
        }
        default: break;
      }
    }
    if (!restartGame && !levelChanged){
      cout << *gameBoard;
    }
  }
}
